\section{Background and Motivating Example}
\label{sec:motivating-example}

Types are sets of run-time values that
overestimate possible run-time values. 
A \textit{type qualifier}~\cite{FosterFFA99}
is a restriction on a type that limits which run-time value
the qualified type can represent. For example, \<positive int>
is a qualifier type: \<positive> is the type qualifier, and \<int>
is the base type.
%
A pluggable type system consists of a hierarchy of type qualifiers.

In practice, pluggable type systems are flow-sensitive.
For example, after a test \codeid{x.f > 0}, the type of \<x.f>
might change from \<int> to \<positive int>
until a possible side effect or a control flow join.
%
Each pluggable typechecker is therefore effectively
an abstract interpretation~\cite{Cousot1997}, with the
abstract interpretation's lattice being equivalent to
the type qualifier hierarchy.

Pluggable type systems in practice are also modular.
For example, consider the following example:

\begin{verbatim}
/** Returns the value in a at the index. The first
    element of the array is index 1. */
int getOneIndexed(int[] a, int index) {
  return a[i - 1];
}
\end{verbatim}

A pluggable typechecker designed to prevent negative array accesses
might require that the type of any array access is non-negative
(assuming that arrays are actually zero-indexed).
%
Because \<index>'s type is an unqualified type from the host language
(\ie a ``base type''),
a pluggable typechecker would \emph{default}
it to a qualifier modeling the worst-case assumption: that \<index> could
be any integer (in type system terminology, this would be referred to
as the ``top qualifier'' or $\top$).
%
To typecheck this code,
a programmer would therefore need to change the type of \<index> from
\<int> to \<positive int> by adding the type qualifier \<positive>:
the typechecker, being modular, would not automatically reason across procedure boundaries.

Our goal in this work is to avoid the burden of writing these type qualifiers
by automatically taking a flow-sensitive, modular pluggable typechecker
like the ones that exist in practice and transforming it into one that performs
inter-procedural inference. Though in this example it was easy to write
the single necessary \<positive> type qualifier, when using practical pluggable
type systems the annotation burden scales linearly with the size of the code
base, and many pluggable type systems require significant numbers of annotations.
For example, a pluggable type system for preventing out-of-bounds array accesses
(with an equivalent to the \<positive> type qualifier from this example) required
one type qualifier for every 32 lines of non-comment, non-blank code~\cite{KelloggDME2018}.
