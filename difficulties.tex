\section{Practical Considerations}
\label{sec:difficulties}

The algorithm and type rules in \cref{sec:algorithm} define our
basic approach. However, there are also some other challenges
that need to be addressed in order to build a system that applies
to every pluggable typechecker and is effective at inferring
type qualifiers for real programs. This section describes the
challenges we encountered while building a tool that implements
the algorithm in \cref{sec:algorithm} and our solutions to those
challenges.

\subsection{Analysis Termination: Infinite Descending Chains and Recursive Calls}
\label{sec:infinite-descending-chains}

The usual lattice definition in an abstract interpretation
(or equivalently, a type system with flow-sensitive refinement like our
pluggable typecheckers~\cite{Cousot1997}) forbids
infinite ascending chains but permits infinite descending chains.
A typechecker whose type system includes an infinite descending chain
is guaranteed to terminate when typechecking a program, but our
inference algorithm can induce downward refinement.

For example, consider a type system for integer intervals
whose type qualifiers are of the form \<@IntRange(from, to)>.
The type \<@IntRange(1, 10) int> therefore means ``an integer between
1 and 10, inclusive'' when running this pluggable typechecker.
The subtyping relationship is straightforward: \<@IntRange(a, z)>
is a supertype of \<@IntRange(b, y)> if and only if \codeid{a < b \&\& z > y}.
Then consider running our inference algorithm on the program in \cref{fig:descend}
using this pluggable typechecker.

\begin{figure}
\begin{verbatim}
int recurse(int x) {
  return recurse(x + 1);
}

recurse(0);
\end{verbatim}
\caption{Simple example which would trigger an infinite loop in a naive
  implementation of our analysis.}
\label{fig:descend}
\end{figure}

When typechecking this program, the pluggable typechecker will
treat both the input and output of \<recurse> as the top type
(\ie any integer). However, the invocation rule in \todo{rules figure}
results in the fixpoint algorithm getting stuck in an arbitrarily-long
loop attempting to infer a type for the parameter \<x>: the call to \<recurse(0)>
results in a qualified type of \<@IntRange(0, 0)> for \<x>. Constant
propagation then leads to the type \<@IntRange(0, 1)> in the next iteration
of the overall fixpoint loop, then to \<@IntRange(0, 2)>, \ldots, which
is undesirable.

In practice, we found that a simple modification to the invocation rule that
prevents type qualifier inference from recursive method calls is sufficient
to prevent this problem in practice. Though mutual recursion is a problem in
theory, in our benchmarks we did not encounter any code that triggered such
an infinite loop in the analysis. Future work should address this problem in
a more principled way.

\subsection{Pre- and Post-conditions}
\label{sec:pre-post-conditions}

Discuss some of the troubles that Mike encountered when
he implemented pre- and post-condition support in WPI. Frame
this as a theoretical problem. \todo{Mike should write this section.}

\subsection{Output Format}
\label{sec:output}

Find a way to frame the various WPI modes (i.e., JAIF mode,
stub mode, ajava mode) as a solution to a theoretical problem.

\todo{Think more about this and remember what other big problems
  we had to solve, and then add corresponding subsections.}
